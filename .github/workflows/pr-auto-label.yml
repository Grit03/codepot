name: PR Auto Labeler

on:
  pull_request:
    types: [opened, reopened, edited]

jobs:
  add-label:
    runs-on: ubuntu-latest
    permissions:
      pull-requests: write

    steps:
      - name: Add Label based on Branch Name
        uses: actions/github-script@v7
        with:
          script: |
            const branchName = context.payload.pull_request.head.ref;

            const labelMap = {
              'feat': 'âœ¨ feat',
              'fix': 'ğŸ› fix',
              'chore': 'âš™ï¸ chore',
              'refactor': 'â™»ï¸ refactor',
              'style': 'ğŸ€ style',
              'docs': 'ğŸ“ docs',
              'test': 'ğŸ§ª test',
              'revert': 'ğŸ”™ revert',
              'hotfix': 'ğŸ”¥ hotfix',
            };

            const prefix = branchName.split('/')[0];

            if (labelMap[prefix]) {
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                labels: [labelMap[prefix]]
              });
              console.log(`ë¼ë²¨ ì¶”ê°€ ì™„ë£Œ: ${labelMap[prefix]}`);
            } else {
              console.log('ë§¤ì¹­ë˜ëŠ” ë¼ë²¨ íŒ¨í„´ì´ ì—†ìŠµë‹ˆë‹¤.');
            }

      - name: Add Label based on Workspace Checkbox
        uses: actions/github-script@v7
        with:
          script: |
            const body = context.payload.pull_request.body || '';

            const workspaceLabels = {
              'web': 'ğŸŒ web',
              'server': 'ğŸ–¥ï¸ server',
            };

            const labelsToAdd = [];
            const labelsToRemove = [];

            for (const [workspace, label] of Object.entries(workspaceLabels)) {
              // ì²´í¬ëœ ì²´í¬ë°•ìŠ¤ íŒ¨í„´: - [x] web ë˜ëŠ” - [X] web
              const checkedPattern = new RegExp(`-\\s*\\[\\s*[xX]\\s*\\]\\s*${workspace}`, 'i');
              // ì²´í¬ ì•ˆëœ ì²´í¬ë°•ìŠ¤ íŒ¨í„´: - [ ] web
              const uncheckedPattern = new RegExp(`-\\s*\\[\\s*\\]\\s*${workspace}`, 'i');

              if (checkedPattern.test(body)) {
                labelsToAdd.push(label);
              } else if (uncheckedPattern.test(body)) {
                labelsToRemove.push(label);
              }
            }

            // ë¼ë²¨ ì¶”ê°€
            if (labelsToAdd.length > 0) {
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                labels: labelsToAdd
              });
              console.log(`Workspace ë¼ë²¨ ì¶”ê°€: ${labelsToAdd.join(', ')}`);
            }

            // ë¼ë²¨ ì œê±° (ì²´í¬ í•´ì œ ì‹œ)
            for (const label of labelsToRemove) {
              try {
                await github.rest.issues.removeLabel({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: context.issue.number,
                  name: label
                });
                console.log(`Workspace ë¼ë²¨ ì œê±°: ${label}`);
              } catch (e) {
                // ë¼ë²¨ì´ ì—†ìœ¼ë©´ ë¬´ì‹œ
                console.log(`ë¼ë²¨ ${label}ì´(ê°€) ì—†ì–´ì„œ ì œê±° ê±´ë„ˆëœ€`);
              }
            }
